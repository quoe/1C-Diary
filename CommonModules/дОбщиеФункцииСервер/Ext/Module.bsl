  
Процедура ЗаписьЖурналаРегистрацииНаСервере(пСсылка, пСообщение = "", пСобытие = "") Экспорт
	
	лСобытие = "";
	
	Если ЗначениеЗаполнено(пСобытие) Тогда
		лСобытие = "." + пСобытие;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Дневник" + лСобытие, УровеньЖурналаРегистрации.Информация,, пСсылка, пСообщение);
	
КонецПроцедуры // ЗаписьЖурналаРегистрацииНаСервере()

Функция ПолучитьПериодЗамераПроизводительности() Экспорт
	
	лПериодЗамераПроизводительности 	= Константы.дПериодЗамераПроизводительности.Получить();
	
	Если НЕ ЗначениеЗаполнено(лПериодЗамераПроизводительности) Тогда
		Константы.дПериодЗамераПроизводительности.Установить(1800);
		лПериодЗамераПроизводительности 	= 1800;
	КонецЕсли;
	
	Возврат лПериодЗамераПроизводительности;
	
КонецФункции // ПолучитьдПериодЗамераПроизводительности() 

Функция ЗагружатьПрогнозПогоды() Экспорт

	ЗагружатьПрогнозПогоды = Константы.дЗагружатьПрогнозПогоды.Получить();
	Возврат ЗагружатьПрогнозПогоды;	
	
КонецФункции // ЗагружатьПрогнозПогоды()
 
Функция ПолучитьАдресПогоды() Экспорт
	
	АдресПогоды = Константы.дАдресПогоды.Получить();
	Возврат АдресПогоды;
	
КонецФункции // ПолучитьАдресПогодыНаСервере()

Функция ЗаписатьПрогнозПогоды() Экспорт 
	//ПрочитатьФайлXMLЧерезDOM(Адрес);
	
	ЗагружатьПрогнозПогоды = Константы.дЗагружатьПрогнозПогоды.Получить();
	Если НЕ ЗагружатьПрогнозПогоды Тогда
		Возврат "";	
	КонецЕсли;
	
	АдресПогоды = Константы.дАдресПогоды.Получить();
	Если НЕ ЗначениеЗаполнено(АдресПогоды) Тогда 
		Сообщить("Адрес прогноза погоды не заполнен, данные получены не будут.", СтатусСообщения.Информация);
		Возврат "";
	КонецЕсли;
	
	ДеревоXML = ЧтениеXMLВДерево(АдресПогоды);
	
	Если ДеревоXML = Неопределено Тогда
		Возврат "";
	КонецЕсли; 
	
	TOWN 		= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки;
	index 		= Число(TOWN[0].Значение);
	sname 		= TOWN[1].Значение;
	latitude 	= Число(TOWN[2].Значение);
	longitude 	= Число(TOWN[3].Значение);
	
	FORECAST 	= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки;
	day 		= Число(FORECAST[0].Значение);
	month 		= Число(FORECAST[1].Значение);
	year 		= Число(FORECAST[2].Значение);
	hour 		= Число(FORECAST[3].Значение);
	tod 		= Число(FORECAST[4].Значение);
	predict 	= Число(FORECAST[5].Значение);
	weekday 	= Число(FORECAST[6].Значение);
	
	PHENOMENA 	= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки[7].Строки;
	PRESSURE 	= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки[8].Строки;
	TEMPERATURE = ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки[9].Строки;
	WIND 		= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки[10].Строки;
	RELWET 		= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки[11].Строки;
	HEAT 		= ДеревоXML.Строки[0].Строки[0].Строки[1].Строки[4].Строки[12].Строки;
	
	// PHENOMENA	
	cloudiness 		= Число(PHENOMENA[0].Значение); // облачность по градациям: -1 - туман, 0 - ясно, 1 - малооблачно, 2 - облачно, 3 - пасмурно
	precipitation 	= Число(PHENOMENA[1].Значение);
	rpower 			= Число(PHENOMENA[2].Значение);
	spower 			= Число(PHENOMENA[3].Значение);
	
	// PRESSURE
	PRESSURE_max 	= Число(PRESSURE[0].Значение);
	PRESSURE_min 	= Число(PRESSURE[1].Значение);
	
	// TEMPERATURE
	TEMPERATURE_max = Число(TEMPERATURE[0].Значение);
	TEMPERATURE_min = Число(TEMPERATURE[1].Значение);
	
	// WIND
	WIND_max 		= Число(WIND[0].Значение);
	WIND_min 		= Число(WIND[1].Значение);
	WIND_direction 	= Число(WIND[2].Значение);
	
	// RELWET
	RELWET_max 		= Число(RELWET[0].Значение);
	RELWET_min 		= Число(RELWET[1].Значение);
	
	// HEAT
	HEAT_max 		= Число(HEAT[0].Значение);
	HEAT_min 		= Число(HEAT[1].Значение);
	
	Если cloudiness = -1 Тогда
		PHENOMENA_cloudiness = Перечисления.дПогодаОблачность[4];	
	Иначе
		PHENOMENA_cloudiness = Перечисления.дПогодаОблачность[cloudiness];
	КонецЕсли;
	
	PHENOMENA_precipitation = Перечисления.дТипОсадков[precipitation - 4];
	PHENOMENA_rpower 		= Перечисления.дИнтенсивностьОсадков[rpower];
	PHENOMENA_spower 		= Перечисления.дВероятностьГрозы[spower];
	
	TEMPERATURE_mid 	= СреднееДвухЧисел(TEMPERATURE_max, TEMPERATURE_min);
	PRESSURE_mid 		= СреднееДвухЧисел(PRESSURE_max	, PRESSURE_min);
	RELWET_mid 			= СреднееДвухЧисел(RELWET_max	, RELWET_min);
	WIND_mid 			= СреднееДвухЧисел(WIND_max		, WIND_min);
	HEAT_mid 			= СреднееДвухЧисел(HEAT_max		, HEAT_min);
	
	Разделитель = "; ";
	Погода = Строка(TEMPERATURE_mid) + "°C" + Разделитель + Строка(PRESSURE_mid) + " мм.рт.ст" + Разделитель + Строка(RELWET_mid) + "%" + Разделитель + Строка(WIND_mid) + " м/с" + Разделитель + Строка(PHENOMENA_cloudiness) + Разделитель + Строка(PHENOMENA_precipitation); 
	
	// Движения в регистр Погоды
	ДатаПогоды 			= Дата(year, month, day, hour, 0, 0);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	дПогода.Период КАК Период
		|ИЗ
		|	РегистрСведений.дПогода КАК дПогода
		|ГДЕ
		|	дПогода.Период = &Период";
	
	Запрос.УстановитьПараметр("Период", ДатаПогоды);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда // Значит уже есть погода на такую дату
		Возврат Погода;
	КонецЕсли; 
	
	Движение 				= РегистрыСведений.дПогода.СоздатьМенеджерЗаписи();
	Движение.Период 		= ДатаПогоды;
	Движение.КодГорода		= index;
	Движение.Широта 		= latitude;
	Движение.Долгота 		= longitude;
	
	Движение.АтмосферныеЯвленияОблачность 		= PHENOMENA_cloudiness; 
	Движение.АтмосферныеЯвленияОсадки 			= PHENOMENA_precipitation;
	Движение.АтмосферныеЯвленияИнтенсивность 	= PHENOMENA_rpower;
	Движение.АтмосферныеЯвленияГроза 			= PHENOMENA_spower;
	
	Движение.АтмосферноеДавлениеМин 	= PRESSURE_min;
	Движение.АтмосферноеДавлениеМакс 	= PRESSURE_max;
	Движение.ВлажностьВоздухаМин 	= RELWET_min;
	Движение.ВлажностьВоздухаМакс 	= RELWET_max;
	Движение.ТемператураМин 	= TEMPERATURE_min;
	Движение.ТемператураМакс 	= TEMPERATURE_max;
	Движение.ВетерМин 			= WIND_min;
	Движение.ВетерМакс 			= WIND_max;
	Движение.ВетерНаправление	= WIND_direction;
	Движение.КомфортМин 	= HEAT_min;
	Движение.КомфортМакс 	= HEAT_max;
	
	Движение.Представление 	= Погода;
	
	Движение.Записать(Ложь);
	
	Возврат Погода;
	
КонецФункции

Функция СреднееДвухЧисел(Первое, Второе)

	Если Первое = Второе Тогда
		Возврат Первое;
	КонецЕсли;
	
	Среднее = (Первое + Второе) / 2;
	Возврат Среднее;

КонецФункции // СреднееДвухЧисел()
 
Процедура ПрочитатьФайлXMLЧерезDOM(ПутьКФайлу)
 
    // Разбор документа через DOM (document object model)
    // https://ru.wikipedia.org/wiki/Document_Object_Model
 
    Парсер = Новый ЧтениеXML;
    Парсер.ОткрытьФайл(ПутьКФайлу);
 
    Построитель = Новый ПостроительDOM;
 
    Документ = Построитель.Прочитать(Парсер);
 
    Для Каждого Элемент0 Из Документ.ЭлементДокумента.ДочерниеУзлы Цикл
        Если Элемент0.ИмяУзла = "REPORT" Тогда
            REPORT = Элемент0;
			Страна = Элемент0;
			
			Для Каждого Элемент1 Из REPORT.ДочерниеУзлы Цикл
				Если Элемент1.ИмяУзла = "TOWN" Тогда
					TOWN = Элемент1;
					
					Для Каждого Элемент2 Из TOWN.ДочерниеУзлы Цикл
						Если Элемент2.ИмяУзла = "FORECAST" Тогда
							FORECAST = Элемент2;
							
							Для Каждого Элемент3 Из FORECAST.ДочерниеУзлы Цикл
								Если Элемент3.ИмяУзла = "PHENOMENA" Тогда
									PHENOMENA = Элемент3;
									
									PHENOMENA_cloudiness = PHENOMENA.Атрибуты.ПолучитьИменованныйЭлемент("cloudiness");
									Если PHENOMENA_cloudiness <> Неопределено Тогда
										Сообщить("== " + PHENOMENA_cloudiness.Значение + " ==");
									КонецЕсли;
								КонецЕсли;
							КонецЦикла;
							
						КонецЕсли;
					Прервать; // Берём только первый прогноз (ближайший)
					КонецЦикла;
				КонецЕсли;
			Прервать; // Берём только первый прогноз (ближайший)
			КонецЦикла;
        КонецЕсли;
    КонецЦикла;
 
    Парсер.Закрыть();
 
КонецПроцедуры

Функция ЧтениеXMLВДерево(Путь)
	
	Дерево = Новый ДеревоЗначений;
	Дерево.Колонки.Добавить("Имя");
	Дерево.Колонки.Добавить("Значение");
	
	XMLФайл = Новый ЧтениеXML;
	XMLФайл.ОткрытьФайл(Путь);
	
	Попытка
		ПрочитатьXMLПоТегам(XMLФайл, Дерево.Строки);
	Исключение
		Сообщить("Не удалось обработать погодные данные");
		ЗаписьЖурналаРегистрации("Дневник.Погода",,,, "Не удалось обработать погодные данные. Ошибка: " + ОписаниеОшибки());
		XMLФайл.Закрыть();
		Возврат Неопределено;
	КонецПопытки;
	
	XMLФайл.Закрыть();
	
	Возврат Дерево;
	
КонецФункции

Процедура ПрочитатьXMLПоТегам(XMLФайл, ТекущийНаборСтрок)
	
	Пока XMLФайл.Прочитать() Цикл
		Если XMLФайл.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			НоваяСтрока = ТекущийНаборСтрок.Добавить();
			НоваяСтрока.Имя = XMLФайл.Имя;
			НоваяСтрока.Значение = "";
			
			Пока XMLФайл.ПрочитатьАтрибут() Цикл
				
				НоваяСтрокаАтрибут = НоваяСтрока.Строки.Добавить();
				НоваяСтрокаАтрибут.Имя = XMLФайл.Имя;
				НоваяСтрокаАтрибут.Значение = СокрЛП(XMLФайл.Значение);
				
			КонецЦикла;
			
			ПрочитатьXMLПоТегам(XMLФайл, НоваяСтрока.Строки);
			
		ИначеЕсли XMLФайл.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Возврат;
		ИначеЕсли XMLФайл.ТипУзла = ТипУзлаXML.Текст Тогда
			
			ТекущийНаборСтрок.Родитель.Значение = СокрЛП(XMLФайл.Значение);
			
		Иначе
			Сообщить("Тип узла: " + XMLФайл.ТипУзла + " НЕ ОБРАБОТАН", СтатусСообщения.Важное);
		Конецесли;
	КонецЦикла;
     
КонецПроцедуры

Функция ПолучитьИнфоСистемы() Экспорт

	Скрипт = Новый COMОбъект("WScript.Network");
	//ЗаголовокСистемы("user "+Скрипт.UserName+" оn "+Скрипт.ComputerName);
	           
	ИмяПользователяСистемы 		= Скрипт.UserName;
	ИмяПользователяСистемыДомен = Скрипт.UserDomain;
	ИмяКомпьютераСистемы 		= Скрипт.ComputerName;
	
	ИнфоСистемы = Новый Структура;
	ИнфоСистемы.Вставить("ИмяПользователяСистемы"	, ИмяПользователяСистемы);
	ИнфоСистемы.Вставить("ИмяДоменаПользователя"	, ИмяПользователяСистемыДомен);
	ИнфоСистемы.Вставить("ИмяКомпьютераСистемы"		, ИмяКомпьютераСистемы);
	
	Возврат ИнфоСистемы;
	
КонецФункции

Процедура ПроверитьРегистрТаблицы(Таблица) Экспорт
	
	ИмяКолонкиДляПроверки = "Слово";
	Для каждого Строка Из Таблица Цикл
		
		СтрокаИмяКолонкиДляПроверки = Строка[ИмяКолонкиДляПроверки]; 
		Если ЗначениеЗаполнено(СтрокаИмяКолонкиДляПроверки) Тогда
			Строка[ИмяКолонкиДляПроверки] = НРег(СтрокаИмяКолонкиДляПроверки);
		КонецЕсли;	
		
	КонецЦикла; 
	 
КонецПроцедуры

//Процедура ПрименитьУсловноеОфомление 
//-------------------------------------------------------------------------
//Параметры:
//		УсловноеОформлениеЭлементы - УсловноеОформление - Напр., "УсловноеОформление.Элементы" или для динамического списка "Список.УсловноеОформление.Элементы"
//		ИмяПроверяемогоЭлемента - Строка - Напр., "Объект.Имя_Проверяемого_Элемента"
//		ВидСравненияКД - ВидСравненияКомпоновкиДанных - ВидСравненияКомпоновкиДанных., напр ВидСравненияКомпоновкиДанных.Равно
//		ПравоеЗначениеОтбора - ЛюбойТип - Ннапр., Истина
//		ИмяОформляемогоЭлемента - Строка - Напр., "Имя_Оформляемого_Элемента". Несколько: "Имя_Оформляемого_Элемента1,Имя_Оформляемого_Элемента2"
//		ИдентификаторПользовательскойНастройки - Строка - Напр., "ИдентификаторПользовательскойНастройки" (ИПН)
//														если заданный ИПН не найден, будет добавлен слемент с этим ИПН
//		ЦветТекста - WebЦвета - Напр., WebЦвета.Черный
//		ЦветФона - WebЦвета - Напр., WebЦвета.Лосоль
//		ЖирныйШрифт - Булево - Напр., Истина
//		СвоеОформление 	- Структура 	- Вида: СвоеОформление = Новый Структура("ЦветТекста", WebЦвета.Синий); 
//-------------------------------------------------------------------------
// Для динамического списка (ДС) для даты можно использовать "Дата.ЧастиДат.Час".
// Так же для ДС нужно обращаться прямо к реквизитам во всех частях
//-------------------------------------------------------------------------
//автор: КучеровРМ 12.02.2019
&НаСервере
Процедура ПрименитьУсловноеОфомление(УсловноеОформлениеЭлементы, ИмяПроверяемогоЭлемента, ВидСравненияКД, ПравоеЗначениеОтбора, ИмяОформляемогоЭлемента, ИдентификаторПользовательскойНастройки = "", ЦветТекста = Неопределено, ЦветФона = Неопределено, ЖирныйШрифт = Ложь, СвоеОформление = Неопределено) Экспорт
	
	//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
	                                       
	Если ПустаяСтрока(ИдентификаторПользовательскойНастройки) Тогда
		ПрисвоитьИдентификаторПользовательскойНастройки 	= ИмяПроверяемогоЭлемента + "_" + ИмяОформляемогоЭлемента;
	КонецЕсли;
	
	ЕстьЭлементСИПН 	= Ложь; // ИдентификаторПользовательскойНастройки
	
	Для каждого ЭлементУО Из УсловноеОформлениеЭлементы Цикл
		
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки Тогда
			ЕстьЭлементСИПН = Истина;
		КонецЕсли; 
		
	КонецЦикла;
	
	Если НЕ ЕстьЭлементСИПН Тогда // Добавляем новое условное офомление
		//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
		ЭлементОформления = УсловноеОформлениеЭлементы.Добавить();
		
		ЭлементОформления.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки;
		// Создаем условие отбора
		ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ЛевоеЗначение 	= Новый ПолеКомпоновкиДанных(ИмяПроверяемогоЭлемента); // ИмяПроверяемогоЭлемента = "Объект.Имя_Проверяемого_Элемента"
		ЭлементОтбора.ВидСравнения 		= ВидСравненияКД; 
		//Значение для отбора
		ЭлементОтбора.ПравоеЗначение 	= ПравоеЗначениеОтбора;
		ЭлементОтбора.Использование 	= Истина;
		// Установка значения элемента УО
		Если ЦветТекста <> Неопределено Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветТекста); // WebЦвета.Черный
		КонецЕсли; 
		Если ЦветФона <> Неопределено Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветФона); // Томатный, Лосоль
		КонецЕсли;
		Если ЖирныйШрифт Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(, 10, Истина,,,,,)); //Выделение жирным шрифтом
		КонецЕсли;
		
		Если СвоеОформление <> Неопределено Тогда
			Для каждого СтруктЭлем Из СвоеОформление Цикл
				
				ЭлементОформления.Оформление.УстановитьЗначениеПараметра(СтруктЭлем.Ключ, СтруктЭлем.Значение);
				
			КонецЦикла; 	
		КонецЕсли; 
		
		// Создаем поля оформления
		ИмяОформляемогоЭлементаМассив 	= СтрРазделить(ИмяОформляемогоЭлемента, ",", Ложь);
		Для каждого ИмяОформляемогоЭлементаМассивЭлем Из ИмяОформляемогоЭлементаМассив Цикл
			
			ПолеОформления 					= ЭлементОформления.Поля.Элементы.Добавить();
			ПолеОформления.Поле 			= Новый ПолеКомпоновкиДанных(СокрЛП(ИмяОформляемогоЭлементаМассивЭлем)); // ИмяОформляемогоЭлемента = "Имя_Оформляемого_Элемента"
			ПолеОформления.Использование 	= Истина;
			
		КонецЦикла; 
		
	КонецЕсли;
	
КонецПроцедуры

Функция СоздатьНовуюЗаписьНаСервере(пОписание = "", пКомментарий = "") Экспорт
	
	лНоваяЗапись 				= Документы.дДневник.СоздатьДокумент();
	лНоваяЗапись.Дата 			= ТекущаяДата();
	лНоваяЗапись.Описание 		= пОписание;
	лНоваяЗапись.Комментарий 	= пКомментарий;
	лНоваяЗапись.Настроение 	= Перечисления.дНастроения.Нормальное;
	
	лНоваяЗапись.Записать(РежимЗаписиДокумента.Проведение);
	
	Возврат лНоваяЗапись.Ссылка;
	
КонецФункции // СоздатьНовуюЗаписьВФоне()

//Параметры:
//	СтруктураПараметров	- Структура, передаваемые в процедуру параметры
//	Адрес  - Адрес временного хранилища, в которое следует поместить данные
Процедура СоздатьНовуюЗаписьНаСервереВФоне(СтруктураПараметров, Адрес = Неопределено) Экспорт
	
	ПоместитьВоВременноеХранилище(Неопределено, Адрес);
	
	лОписание 		= СтруктураПараметров.пОписание;
	лКомментарий 	= СтруктураПараметров.пКомментарий;
	
	лНоваяЗапись 	= СоздатьНовуюЗаписьНаСервере(лОписание, лКомментарий);
	
	ПоместитьВоВременноеХранилище(лНоваяЗапись, Адрес);
	
КонецПроцедуры // СоздатьНовуюЗаписьНаСервереВФоне()

&НаСервере
Процедура УстановитьОтборСписка(пСписокОтборЭлементы, пИмяПоля, пЗначение) Экспорт
	
	ЭлементОтбора = пСписокОтборЭлементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	//ЭлементОтбора.Родитель = ГруппаОтбора;
	ЭлементОтбора.ЛевоеЗначение 	= Новый ПолеКомпоновкиДанных(пИмяПоля);
	ЭлементОтбора.ВидСравнения 		= ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбора.Использование 	= Истина;
	ЭлементОтбора.ПравоеЗначение 	= пЗначение;
	
КонецПроцедуры // УстановитьОтборСписка()

Функция ПроверитьПолучитьСправочникПустаяСсылка(пИмяЭлемента) Экспорт

	Если Метаданные.Справочники.Найти(пИмяЭлемента) <> Неопределено Тогда
		Возврат Справочники[пИмяЭлемента].ПустаяСсылка();	
	КонецЕсли;	

КонецФункции // ПроверитьПолучитьСправочникПустаяСсылка()

////////////////////////////////////////////////////////////////////////////////
// 1С 8.3 : Дерево значений в таблицу значений или в табличную часть и обратно
// //https://helpf.pro/faq83/view/1588.html
////////////////////////////////////////////////////////////////////////////////

//Процедура КомандаТаблицуВДеревоНаСервере()
//	Дерево = ТаблицаВДерево(РеквизитФормыВЗначение("Объект"), "Товары");//Товары - имя табличной части
//	ЗначениеВРеквизитФормы(Дерево, "ДеревоЗначений");//ДеревоЗначений - реквизит формы с типом дерево значений
//	Элементы.ДеревоЗначений.Обновить();
//КонецПроцедуры

//Процедура КомандаДеревоВТаблицуНаСервере()
//	Объект.Товары.Очистить();
//	ДОбъект = РеквизитФормыВЗначение("Объект");
//	ДеревоВТаблицу(ДОбъект, РеквизитФормыВЗначение("ДеревоЗначений"), "Товары");
//	ЗначениеВРеквизитФормы(ДОбъект, "Объект");
//КонецПроцедуры   

//ФОРМИРОВАНИЕ ТАБЛИЦЫ ИЗ ДЕРЕВА
&НаСервере
Процедура ДеревоВТаблицу(ДокОбъект, ДеревоЗначений, НаименованиеТабличнойЧастиДокумента, СтрокаДерева = Неопределено, КлючСвязи = Неопределено) Экспорт
	
	Если СтрокаДерева = Неопределено И КлючСвязи = Неопределено Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов 	= Истина;
		ДокОбъект[НаименованиеТабличнойЧастиДокумента].Очистить();
		ИсточникВыборки = ДеревоЗначений.Строки;
		КлючСвязи 		= Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"); // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов 	= Ложь;
		ИсточникВыборки = СтрокаДерева.Строки;
	КонецЕсли;
	
	Для каждого Стр из ИсточникВыборки Цикл
		
		НС 	= ДокОбъект[НаименованиеТабличнойЧастиДокумента].Добавить();
		лМетаданныеТЧ 	= ДокОбъект.Метаданные().ТабличныеЧасти[НаименованиеТабличнойЧастиДокумента];
		
		ЗаполнитьЗначенияСвойств(НС, Стр);
		
		НС.КлючСвязи 	= КлючСвязи;
		
		лСтрКоличество 	= Стр.Строки.Количество();
		Если лСтрКоличество > 0 Тогда
			НС.КоличествоЭлементов 		= лСтрКоличество;
			Стр.КоличествоЭлементов 	= лСтрКоличество;
		КонецЕсли;
		
		//Для каждого Кол из лМетаданныеТЧ.Реквизиты Цикл
		//	Если Кол.Имя = "КлючСвязи" Тогда
		//		НС.КлючСвязи = КлючСвязи;
		//	ИначеЕсли Кол.Имя = "НомерСтроки" Тогда
		//		Продолжить;
		//	Иначе 
		//		ЗаполнитьЗначенияСвойств(НС, Стр);
		//		//НС[Кол.Имя] = Стр[Кол.Имя];
		//	КонецЕсли;
		//КонецЦикла;
		Если НЕ Стр.Строки.Количество() = 0 Тогда
			ДеревоВТаблицу(ДокОбъект,,НаименованиеТабличнойЧастиДокумента, Стр, НС.ЭлементИД);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры 

&НаСервере
Процедура ДеревоПересчитатьЭлементы(ДокОбъект, ДеревоЗначений, НаименованиеТабличнойЧастиДокумента, СтрокаДерева = Неопределено, КлючСвязи = Неопределено) Экспорт
	
	Если СтрокаДерева = Неопределено И КлючСвязи = Неопределено Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов 	= Истина;
		ИсточникВыборки = ДеревоЗначений.Строки;
		КлючСвязи 		= Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"); // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов 	= Ложь;
		ИсточникВыборки = СтрокаДерева.Строки;
	КонецЕсли;
	
	Для каждого Стр из ИсточникВыборки Цикл
		
		лСтрКоличество 	= Стр.Строки.Количество();
		Если лСтрКоличество > 0 Тогда
			Стр.КоличествоЭлементов 	= лСтрКоличество;
		КонецЕсли;
		
		Если НЕ Стр.Строки.Количество() = 0 Тогда
			ДеревоПересчитатьЭлементы(ДокОбъект,,НаименованиеТабличнойЧастиДокумента, Стр, Стр.ЭлементИД);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

//ФОРМИРОВАНИЕ ДЕРЕВА ИЗ ТАБЛИЦЫ
&НаСервере
Функция ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, КлючСвязи = Неопределено, ЭлементРодитель = Неопределено) Экспорт	
	//ПОДГОТОВКА КОЛОНОК ДЕРЕВА
	КолонкиТаблицы 	= ДокОбъект.Метаданные().ТабличныеЧасти[НаименованиеТабличнойЧастиДокумента].Реквизиты;
	ДеревоЗначений2 = Новый ДеревоЗначений;
	
	НовыйИД 		= Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	Для каждого Кол из КолонкиТаблицы Цикл
		Если Кол.Имя = "НомерСтроки" ИЛИ Кол.Имя = "КлючСвязи" Тогда
			Продолжить;
		Иначе
			ДеревоЗначений2.Колонки.Добавить(Кол.Имя, Новый ОписаниеТипов(Кол.Тип));
		КонецЕсли;
	КонецЦикла;//ДеревоЗначений.Строки.Очистить();
	
	Если КлючСвязи = Неопределено И ЭлементРодитель = Неопределено Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ИсточникВыборки = ДеревоЗначений2.Строки;
		КлючСвязи 		= НовыйИД; // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ИсточникВыборки = ЭлементРодитель.Строки;
	КонецЕсли;
	
	Фильтр 					= Новый Структура("КлючСвязи", КлючСвязи);
	лДочерниеПоКлючуСвязи 	= ДокОбъект[НаименованиеТабличнойЧастиДокумента].НайтиСтроки(Фильтр);
	Если лДочерниеПоКлючуСвязи.Количество() = 0 Тогда
		Возврат ДеревоЗначений2;
	КонецЕсли;
	
	Для каждого Стр из лДочерниеПоКлючуСвязи Цикл
		
		//Для каждого Кол из КолонкиТаблицы Цикл
		//	Если Кол.Имя = "НомерСтроки" ИЛИ Кол.Имя = "КлючСвязи" Тогда
		//		Продолжить;
		//	Иначе
		//		Элемент[Кол.Имя] = Стр[Кол.Имя];
		//	КонецЕсли;
		//КонецЦикла;
		
		Если КлючСвязи = НовыйИД И ЭлементРодитель = Неопределено Тогда
			Элемент 	= ИсточникВыборки.Добавить();
			ЗаполнитьЗначенияСвойств(Элемент, Стр);
			ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, Стр.ЭлементИД, Элемент); //ДОБАВЛЕНИЕ ПОДЧИНЁННЫХ ЭЛЕМЕНТОВ В ДЕРЕВО
			Прервать; //Заполнив корневой уровень и выйдя, т.к. в нём все элементы
			
		Иначе
			Если Стр.ЭлементИД <> НовыйИД Тогда
				Элемент 	= ИсточникВыборки.Добавить();
				ЗаполнитьЗначенияСвойств(Элемент, Стр);
				ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, Стр.ЭлементИД, Элемент); //ДОБАВЛЕНИЕ ПОДЧИНЁННЫХ ЭЛЕМЕНТОВ В ДЕРЕВО
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДеревоЗначений2;
	
КонецФункции

Процедура ЗаписатьПроизводительность(пПроизводительностьПроцессы) Экспорт

	лКомпИнфо 			= Новый Структура("ComputerName, UserDomain, UserName, Пользователь", ПараметрыСеанса.дИмяКомпьютераСистемы, ПараметрыСеанса.дИмяДоменаПользователя, ПараметрыСеанса.дИмяПользователяСистемы, ИмяПользователя());
	
	//Процессы
	лНаборЗаписей 		= РегистрыСведений.дПроцессы.СоздатьНаборЗаписей();
	ЗаполнитьЗначенияСвойств(лНаборЗаписей.Отбор, лКомпИнфо);
	
	лДата 		= пПроизводительностьПроцессы.Период;
	лПроцессы 	= пПроизводительностьПроцессы.Процессы;
	Для каждого Элем Из лПроцессы Цикл
		
		лНоваяЗапись 			= лНаборЗаписей.Добавить();
		лНоваяЗапись.Период 	= лДата;
		
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, лКомпИнфо);
		
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, Элем);
		
	КонецЦикла;
	
	лНаборЗаписей.Записать(Ложь);
	
	лЗагруженность 	= пПроизводительностьПроцессы.Загруженность;
	
	//Производительность
	лМенеджерЗаписи 		= РегистрыСведений.дПроизводительность.СоздатьМенеджерЗаписи();
	лМенеджерЗаписи.Период 	= лДата;
	ЗаполнитьЗначенияСвойств(лМенеджерЗаписи, лКомпИнфо);
	ЗаполнитьЗначенияСвойств(лМенеджерЗаписи, лЗагруженность.WmiЗагруженность);
	ЗаполнитьЗначенияСвойств(лМенеджерЗаписи, лЗагруженность.Загруженность);
	
	лМенеджерЗаписи.Записать(Ложь);
	
	//Место
	лНаборЗаписей 		= РегистрыСведений.дМестоНаДисках.СоздатьНаборЗаписей();
	
	лМестоНаДисках 		= пПроизводительностьПроцессы.МестоНаДисках;
	Для каждого Элем Из лМестоНаДисках Цикл
		
		лНоваяЗапись 			= лНаборЗаписей.Добавить();
		лНоваяЗапись.Период 	= лДата;
		
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, лКомпИнфо);
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, Элем.Значение);
		
	КонецЦикла;

	лНаборЗаписей.Записать(Ложь);
	
	//Сеть
	лНаборЗаписей 			= РегистрыСведений.дСетеваяАктивность.СоздатьНаборЗаписей();
	
	лСетеваяАктивность 		= пПроизводительностьПроцессы.СетеваяАктивность;
	Для каждого Элем Из лСетеваяАктивность Цикл
		
		лНоваяЗапись 			= лНаборЗаписей.Добавить();
		лНоваяЗапись.Период 	= лДата;
		
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, лКомпИнфо);
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, Элем);
		
		//Получим последнюю сетевую активность, чтобы узнать сколько прибыло за интервал времени
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	дСетеваяАктивностьСрезПоследних.БайтОтправлено КАК БайтОтправлено,
		|	дСетеваяАктивностьСрезПоследних.БайтПринято КАК БайтПринято
		|ИЗ
		|	РегистрСведений.дСетеваяАктивность.СрезПоследних КАК дСетеваяАктивностьСрезПоследних
		|ГДЕ
		|	дСетеваяАктивностьСрезПоследних.UserName = &UserName
		|	И дСетеваяАктивностьСрезПоследних.ComputerName = &ComputerName
		|	И дСетеваяАктивностьСрезПоследних.UserDomain = &UserDomain
		|	И дСетеваяАктивностьСрезПоследних.ID = &ID
		|	И дСетеваяАктивностьСрезПоследних.Наименование = &Наименование";
		
		Запрос.УстановитьПараметр("ComputerName", лКомпИнфо.ComputerName);
		Запрос.УстановитьПараметр("ID"			, Элем.ID);
		Запрос.УстановитьПараметр("UserDomain"	, лКомпИнфо.UserDomain);
		Запрос.УстановитьПараметр("UserName"	, лКомпИнфо.UserName);
		Запрос.УстановитьПараметр("Наименование", Элем.Наименование);
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если НЕ РезультатЗапроса.Пустой() Тогда
			лВыборка 	= РезультатЗапроса.Выбрать();
			Если лВыборка.Следующий() Тогда
				лСрезБайтОтправлено 	= лВыборка.БайтОтправлено;
				лСрезБайтПринято 		= лВыборка.БайтПринято;
				
				лБайтОтправленоИзм 		= Элем.БайтОтправлено - лСрезБайтОтправлено;
				лБайтПринятоИзм 		= Элем.БайтПринято - лСрезБайтПринято;
				
				лНоваяЗапись.БайтОтправленоИзменение 	= ?(лБайтОтправленоИзм > 0, лБайтОтправленоИзм, 0);
				лНоваяЗапись.БайтПринятоИзменение 		= ?(лБайтПринятоИзм > 0, лБайтПринятоИзм, 0);
			КонецЕсли;
		Иначе
			лНоваяЗапись.БайтОтправленоИзменение 	= 0;
			лНоваяЗапись.БайтПринятоИзменение 		= 0;
		КонецЕсли;  
		
	КонецЦикла;
	
	лНаборЗаписей.Записать(Ложь);
	
	//Загрузка памяти
	лНаборЗаписей 		= РегистрыСведений.дПамять.СоздатьНаборЗаписей();
	
	лЗагрузкаПамяти 	= пПроизводительностьПроцессы.ЗагрузкаПамяти;
	Для каждого Элем Из лЗагрузкаПамяти Цикл
		
		лНоваяЗапись 			= лНаборЗаписей.Добавить();
		лНоваяЗапись.Период 	= лДата;
		
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, лКомпИнфо);
		ЗаполнитьЗначенияСвойств(лНоваяЗапись, Элем);
		
	КонецЦикла;

	лНаборЗаписей.Записать(Ложь);
	
КонецПроцедуры
 
&НаСервере
Процедура СоздатьДокументСоСсылкой(НовыйОбъект, СсылкаНаЗапись) Экспорт
	
	НовыйРезультат 					= НовыйОбъект.Результат.Добавить();
	НовыйРезультат.ИмяРезультата 	= Справочники.дРезультат.СсылкаНаЗапись;
	НовыйРезультат.Параметр 		= СсылкаНаЗапись;
	
КонецПроцедуры

Функция ПеревестиТекстЧерезЯндекс(пТекст, пПеревод = "ru-en", пСсылка = Неопределено) Экспорт
	
	//https://cloud.yandex.ru/services/translate
	//https://yandex.ru/dev/translate/doc/dg/concepts/about.html
	//https://translate.yandex.ru/developers/keys
	//https://tech.yandex.com/translate/doc/dg/reference/translate-docpage/#JSON
	//https://translate.yandex.net/api/v1.5/tr.json/translate?lang=ru-en&text=%D0%90%D0%B1%D0%B2%20%D0%BA%D0%BE%D1%82&key=trnsl.1.1.20200322T133007Z.32e7d1a2778945f2.0b14aba0e2eda937e6414414a3ada4a6e3126adb
	ОтветРезультат       = Неопределено;
	
	ПараметрыЗапроса     = Новый Структура;
	ПараметрыЗапроса.Вставить("key"    , "trnsl.1.1.20200322T133007Z.32e7d1a2778945f2.0b14aba0e2eda937e6414414a3ada4a6e3126adb");
	ПараметрыЗапроса.Вставить("lang", пПеревод);
	ПараметрыЗапроса.Вставить("text", пТекст);
	
	Попытка
	
		Ответ         = КоннекторHTTP.GetJson("https://translate.yandex.net/api/v1.5/tr.json/translate", ПараметрыЗапроса);    
		ОтветТекст    = Ответ.Получить("text");
		
		Если ОтветТекст <> Неопределено И ОтветТекст.Количество() > 0 Тогда
			ОтветРезультат = ОтветТекст[0];
		Иначе
			ЗаписьЖурналаРегистрацииНаСервере(Документы.дДневник.ПустаяСсылка(), "Пустой ответ от перевода текста через Яндекс", "Перевод");
		КонецЕсли;	
	
	Исключение            
		лСообщение 	= "Ошибка: " + ОписаниеОшибки();
    	ЗаписьЖурналаРегистрацииНаСервере(Документы.дДневник.ПустаяСсылка(), "Ошибка при переводе текста через Яндекс. " + лСообщение, "Перевод");
	КонецПопытки; 
	
	Тест = ПеревестиТекстЧерезRapidapi(пТекст,,, пСсылка);
	
	Возврат ОтветРезультат; 
	
КонецФункции

Функция ПеревестиТекстЧерезRapidapi(пТекст, пСКакого = "ru", пНаКакой = "en", пСсылка = Неопределено) Экспорт
	
	//https://rapidapi.com/ru/datascraper/api/google-translate20/
	//Бесплатно 300 / месяц
	//+ $0.001 друг друга

	ОтветРезультат       = Неопределено;
	Если ПустаяСтрока(пТекст) Тогда			   
		Возврат ОтветРезультат;
	КонецЕсли;
	
	лСКакого = "ru";
	лНаКакой = "en";
	
	Если пСКакого = Справочники.дЯзыки.Русский Тогда
		лСКакого = "ru";
	КонецЕсли;
	Если пНаКакой = Справочники.дЯзыки.АнглийскийМашинный Тогда
		лНаКакой = "en";
	КонецЕсли;
	
	Заголовки     = Новый Соответствие;
	Заголовки.Вставить("x-rapidapi-host", "google-translate20.p.rapidapi.com");
	Заголовки.Вставить("x-rapidapi-key"	, "");
	
	ПараметрыЗапроса     = Новый Структура;
	ПараметрыЗапроса.Вставить("text", пТекст);
	ПараметрыЗапроса.Вставить("sl"	, лСКакого);
	ПараметрыЗапроса.Вставить("tl"	, лНаКакой);

	Попытка
	
		Ответ         = КоннекторHTTP.GetJson("https://google-translate20.p.rapidapi.com/translate", ПараметрыЗапроса, Новый Структура("Заголовки", Заголовки));    
		
		Если Ответ <> Неопределено И Ответ.Количество() > 0 Тогда
			Ответ_data    = Ответ.Получить("data");
			Если ЗначениеЗаполнено(Ответ_data) Тогда
				Ответ_translation = Ответ_data.Получить("translation");
			КонецЕсли;
			ОтветРезультат = Ответ_translation; 
		Иначе                                      
			ЗаписьЖурналаРегистрацииНаСервере(пСсылка, "Пустой ответ от перевода текста через Rapidapi", "Перевод");
		КонецЕсли;
	
	Исключение       
		лСообщение 	= "Ошибка: " + ОписаниеОшибки();
		ЗаписьЖурналаРегистрацииНаСервере(пСсылка, "Ошибка при переводе текста через Rapidapi. " + лСообщение, "Перевод");	
	КонецПопытки; 
	
	Возврат ОтветРезультат; 

//“af”:“Afrikaans”
//“am”:“Amharic”
//“ar”:“Arabic”
//“auto”:“Detect Language”
//“az”:“Azerbaijani”
//“be”:“Belarusian”
//“bg”:“Bulgarian”
//“bn”:“Bengali”
//“bs”:“Bosnian”
//“ca”:“Catalan”
//“ceb”:“Cebuano”
//“co”:“Corsican”
//“cs”:“Czech”
//“cy”:“Welsh”
//“da”:“Danish”
//“de”:“German”
//“el”:“Greek”
//“en”:“English”
//“eo”:“Esperanto”
//“es”:“Spanish”
//“et”:“Estonian”
//“eu”:“Basque”
//“fa”:“Persian”
//“fi”:“Finnish”
//“fr”:“French”
//“fy”:“Frisian”
//“ga”:“Irish”
//“gd”:“Scots Gaelic”
//“gl”:“Galician”
//“gu”:“Gujarati”
//“ha”:“Hausa”
//“haw”:“Hawaiian”
//“he”:“Hebrew”
//“hi”:“Hindi”
//“hmn”:“Hmong”
//“hr”:“Croatian”
//“ht”:“Haitian Creole”
//“hu”:“Hungarian”
//“hy”:“Armenian”
//“id”:“Indonesian”
//“ig”:“Igbo”
//“is”:“Icelandic”
//“it”:“Italian”
//“iw”:“Hebrew”
//“ja”:“Japanese”
//“jw”:“Javanese”
//“ka”:“Georgian”
//“kk”:“Kazakh”
//“km”:“Khmer”
//“rw”: “Kinyarwanda”
//“kn”:“Kannada”
//“ko”:“Korean”
//“ku”:“Kurdish (Kurmanji)”
//“ky”:“Kyrgyz”
//“la”:“Latin”
//“lb”:“Luxembourgish”
//“lo”:“Lao”
//“lt”:“Lithuanian”
//“lv”:“Latvian”
//“mg”:“Malagasy”
//“mi”:“Maori”
//“mk”:“Macedonian”
//“ml”:“Malayalam”
//“mn”:“Mongolian”
//“mr”:“Marathi”
//“ms”:“Malay”
//“mt”:“Maltese”
//“my”:“Myanmar (Burmese)”
//“ne”:“Nepali”
//“nl”:“Dutch”
//“no”:“Norwegian”
//“or”: “Odia (Oriya)”
//“ny”:“Chichewa”
//“pa”:“Punjabi”
//“pl”:“Polish”
//“ps”:“Pashto”
//“pt”:“Portuguese”
//“ro”:“Romanian”
//“ru”:“Russian”
//“sd”:“Sindhi”
//“si”:“Sinhala”
//“sk”:“Slovak”
//“sl”:“Slovenian”
//“sm”:“Samoan”
//“sn”:“Shona”
//“so”:“Somali”
//“sq”:“Albanian”
//“sr”:“Serbian”
//“st”:“Sesotho”
//“su”:“Sundanese”
//“sv”:“Swedish”
//“sw”:“Swahili”
//“ta”:“Tamil”
//“tt”: “Tatar”
//“te”:“Telugu”
//“tg”:“Tajik”
//“th”:“Thai”
//“tl”:“Filipino”
//“tr”:“Turkish”
//“uk”:“Ukrainian”
//“ur”:“Urdu”
//“ug”: “Uyghur”
//“uz”:“Uzbek”
//“vi”:“Vietnamese”
//“xh”:“Xhosa”
//“yi”:“Yiddish”
//“yo”:“Yoruba”
//“zh-CN”:“Chinese (Simplified)”
//“zh-TW”:“Chinese (Traditional)”
//“zu”:“Zulu”

КонецФункции
